-----------------
MD5 信息摘要算法
-----------------

关于本备忘录

    本备忘录为 Internet 社区提供信息。它没有指定一个 Internet 标准。分发本备忘录是没有\
    限制的。

致谢

    我们对提出许多有益的意见和建议的 Don Coppersmith, Burt Kaliski, Ralph Merkle, \
    David Chaum, 和 Noam Nisan 表示感谢。

目录

1. 执行摘要_
#. 术语和符号_
#. `MD5 算法描述`_
#. 摘要_
#. `MD4 和 MD5 的差异`_

* `参考文献`_
* `附录 A - 参考实例`_
* `安全注意事项`_
* `作者地址`_ 

.. _执行摘要:

.. 执行摘要

1. 执行摘要
------------

本文档记述了 MD5 信息摘要算法。该算法将任意长度的信息作为输入，并输出一个输入信息的\
128位的 “指纹” 或者 “信息摘要”。据推测，生成两个具有相同信息摘要的信息，或者生成预\
定目标信息摘要的任何信息，在计算上是不可行的。MD5 算法适用于应用程序的数字签名，在\
使用诸如 RSA 之类的公钥加密系统的私有（秘密）秘钥对其进行加密之前，必须先以安全的方\
式压缩大文件。

MD5 算法被设计的非常快在32位计算机上。另外，MD5 算法不需要任何庞大的置换表；该算法\
可以非常紧凑地编码。

MD5 算法是 MD4 信息摘要算法 [1]_ [2]_ 的拓展。MD5 算法稍慢于 MD4 算法，但是在设计\
上更为“保守”。MD5 算法之所以被设计，是因为人们认为 MD4 算法可能被采纳为比现有的重要\
审查所证明的合理的速度还要快；正因为 MD4 被设计地出乎意料的快，所以在成功的密码分析\
攻击分析方面，它处于“边缘”。MD5 稍微后退了一点儿，为了提高最终安全性而放弃了一些速\
度。它包含了各位审阅者提出的一些建议，并包含了额外的优化。MD5 算法正在公共领域中进\
行审查，并有可能被采纳为标准。

对于基于 OSI 的应用程序，MD5的对象标识符为：

.. code-block:: 

    md5 OBJECT IDENTIFIER ::=
    iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 5}

在 X.509 类型的算法识别符 [3]_ 中，MD5 算法的参数应该包含 NULL 类型。

.. _术语和符号:

.. 术语和符号

2. 术语和符号
-------------

在本文档中，一个 “字（word）” 是 32 位长度，一个 “字节（byte）” 是 8 位长度。可以\
按自然的方式将位（bit）序列解释为字节序列，其中，每 8 位连续的位被解释为一个字节，每\
个字节的高位（最高有效位）位于第一位。相似地，字节序列可以解释为 32 位的字，其中每 \
4 个连续的字节被解释为一个字，每个字的低位（最低有效位）位于第一位。

用 x_i 表示 “x 的下标 i”，如果下标是一个表达式，我们将它放在大括号内，如 x_{i+1}。\
同样地，我们使用 ``^`` 表示上标（取幂），以便 x^i 表示 x 的第 i 次幂。

令符号 “+” 表示 字 的加法运算（即模 2^32 加法）。令 ``X <<< s`` 表示通过将 X 向左\
循环移位 s 个位而取得 32 位的值。令 ``not(x)`` 表示 x 的按位补码，令 ``X v Y`` \
表示 X 和 Y 的按位或运算。令 ``X xor Y`` 表示 X 和 Y 的按位异或运算， ``XY`` 表\
示 X 和 Y 的按位与运算。

.. _MD5 算法描述:

.. MD5 算法描述

3. MD5 算法描述
---------------

首先我们假设有一个 b 位的信息作为输入，并且希望找到其信息摘要。这里的 b 是一个任意\
的非负整数；b 可以为零，不必为 8 的倍数，而且可以任意大。我们假设将消息的各个部分记\
录如下:

    m_0 m_1 ... m_{b-1}

接下来的 5 个步骤来计算消息的信息摘要。

3.1 步骤 1. 填充比特
~~~~~~~~~~~~~~~~~~~~~

对该消息进行“填充（拓展）”，以使其长度（以 bit 为单位）等于 448，以512为模。即，\
对该消息进行拓展，使它的长度比 512 位的整数倍长度少 64 位。消息填充是始终进行的，\
即使消息的长度已经等于 448（以512位模）。

填充操作如下：将单个的 "1" 添加到消息中，然后添加 "0"，以使填充消息的位长度等于 \
448，模数为 512。总之，至少 1 位，至多 512 位会被填充。

3.2 步骤 2. 附加长度
~~~~~~~~~~~~~~~~~~~~~

b 的 64 位表示形式（填充数据之前）将附加到上一步的结果中。如果 b 大于 2^64，则\
仅使用 b 的低 64 位（根据以前的惯例，这些位被附加为两个 32 字，并首先附加到低位。）

此时，结果消息（用位填充和 b 填充之后）的长度时 512 位的精确倍数。同样，此消息的\
长度是 16 （32 位）字的整数倍。令 M[0 ... N-1] 表示结果消息的字，其中 N 是 16 \
的倍数。

3.3 步骤 3. 初始化 MD 缓冲区
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一个四字缓冲区（A, B, C, D）用于计算信息摘要。在此，A, B, C, D 均为 32 位寄存\
器。这些寄存器被初始化为以下值（十六进制，低位在前）：

.. code-block:: 

    A: 01 23 45 67
    B: 89 ab cd ef
    C: fe dc ba 98
    D: 76 54 32 10

3.4 步骤 4. 以 16 字块形式处理消息
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们首先定义四个辅助函数，每个辅助函数将三个32位字作为输入，并产生一个32位字作为\
输出。

.. code-block:: 

    F(X,Y,Z) = XY v not(X) Z
    G(X,Y,Z) = XZ v Y not(Z)
    H(X,Y,Z) = X xor Y xor Z
    I(X,Y,Z) = Y xor (X v not(Z))

*这一段不知道怎么翻译*

In each bit position F acts as a conditional: if X then Y else Z.
The function F could have been defined using + instead of v since XY
and not(X)Z will never have 1's in the same bit position.) It is
interesting to note that if the bits of X, Y, and Z are independent
and unbiased, the each bit of F(X,Y,Z) will be independent and
unbiased.

The functions G, H, and I are similar to the function F, in that they
act in "bitwise parallel" to produce their output from the bits of X,
Y, and Z, in such a manner that if the corresponding bits of X, Y,
and Z are independent and unbiased, then each bit of G(X,Y,Z),
H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that
the function H is the bit-wise "xor" or "parity" function of its
inputs.

This step uses a 64-element table T[1 ... 64] constructed from the
sine function. Let T[i] denote the i-th element of the table, which
is equal to the integer part of 4294967296 times abs(sin(i)), where i
is in radians. The elements of the table are given in the appendix.

Do the following:

.. code-block:: 

    /* Process each 16-word block. */
    For i = 0 to N/16-1 do

        /* Copy block i into X. */
        For j = 0 to 15 do
            Set X[j] to M[i*16+j].
        end /* of loop on j */

        /* Save A as AA, B as BB, C as CC, and D as DD. */
        AA = A
        BB = B

        CC = C
        DD = D

        /* Round 1. */
        /* Let [abcd k s i] denote the operation
            a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
        /* Do the following 16 operations. */
        [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
        [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
        [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
        [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]

        /* Round 2. */
        /* Let [abcd k s i] denote the operation
            a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
        /* Do the following 16 operations. */
        [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
        [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
        [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
        [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]

        /* Round 3. */
        /* Let [abcd k s t] denote the operation
            a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
        /* Do the following 16 operations. */
        [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
        [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
        [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
        [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]

        /* Round 4. */
        /* Let [abcd k s t] denote the operation
            a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
        /* Do the following 16 operations. */
        [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
        [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
        [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
        [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]

        /* Then perform the following additions. (That is increment each
            of the four registers by the value it had before this block
            was started.) */
        A = A + AA
        B = B + BB
        C = C + CC
        D = D + DD

    end /* of loop on i */

3.5 步骤 5. 输出
~~~~~~~~~~~~~~~~~~~~~

.. _摘要:

.. 摘要

4. 摘要
---------

.. _MD4 和 MD5 的差异:

.. MD4 和 MD5 的差异

5. MD4 和 MD5 的差异
--------------------

.. _参考文献:

参考文献


.. [1] Rivest, R., "The MD4 Message Digest Algorithm",RFC 1320, MIT and RSA \
       Data Security, Inc., April 1992.

.. [2] Rivest, R., "The MD4 message digest algorithm", in A.J.  Menezes and \
       S.A. Vanstone, editors, Advances in Cryptology - CRYPTO '90 \
       Proceedings, pages 303-311, Springer-Verlag, 1991.

.. [3] CCITT Recommendation X.509 (1988), "The Directory Authentication \
       Framework."

.. _附录 a - 参考实例:

附录 a - 参考实例

.. _安全注意事项:

安全注意事项

.. _作者地址:

作者地址
